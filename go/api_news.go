/*
World News API

The world's news wrapped into a single API.

API version: 1.0
Contact: mail@worldnewsapi.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
)

// Linger please
var (
	_ context.Context
)

// NewsApiService NewsApi service
type NewsApiService service

type ApiExtractNewsRequest struct {
	ctx context.Context
	ApiService *NewsApiService
	url *string
	analyze *bool
}

// The url of the news.
func (r ApiExtractNewsRequest) Url(url string) ApiExtractNewsRequest {
	r.url = &url
	return r
}
// Whether to analyze the news (extract entities etc.)
func (r ApiExtractNewsRequest) Analyze(analyze bool) ApiExtractNewsRequest {
	r.analyze = &analyze
	return r
}

func (r ApiExtractNewsRequest) Execute() (*InlineResponse2001, *http.Response, error) {
	return r.ApiService.ExtractNewsExecute(r)
}

/*
ExtractNews Extract News

Extract a news entry from a news site.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiExtractNewsRequest
*/
func (a *NewsApiService) ExtractNews(ctx context.Context) ApiExtractNewsRequest {
	return ApiExtractNewsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse2001
func (a *NewsApiService) ExtractNewsExecute(r ApiExtractNewsRequest) (*InlineResponse2001, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse2001
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NewsApiService.ExtractNews")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extract-news"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.url == nil {
		return localVarReturnValue, nil, reportError("url is required and must be specified")
	}
	if r.analyze == nil {
		return localVarReturnValue, nil, reportError("analyze is required and must be specified")
	}

	localVarQueryParams.Add("url", parameterToString(*r.url, ""))
	localVarQueryParams.Add("analyze", parameterToString(*r.analyze, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api-key", key)
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["headerApiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtractNews_0Request struct {
	ctx context.Context
	ApiService *NewsApiService
	url *string
	apiKey *string
	prefix *string
	subDomain *bool
}

// The url from which links should be extracted.
func (r ApiExtractNews_0Request) Url(url string) ApiExtractNews_0Request {
	r.url = &url
	return r
}
// Your API key.
func (r ApiExtractNews_0Request) ApiKey(apiKey string) ApiExtractNews_0Request {
	r.apiKey = &apiKey
	return r
}
// The prefix the news links must start with.
func (r ApiExtractNews_0Request) Prefix(prefix string) ApiExtractNews_0Request {
	r.prefix = &prefix
	return r
}
// Whether to include links to news on sub-domains.
func (r ApiExtractNews_0Request) SubDomain(subDomain bool) ApiExtractNews_0Request {
	r.subDomain = &subDomain
	return r
}

func (r ApiExtractNews_0Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ExtractNews_1Execute(r)
}

/*
ExtractNews_0 Extract News

Extract a news links from a news website. 

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiExtractNews_0Request
*/
func (a *NewsApiService) ExtractNews_1(ctx context.Context) ApiExtractNews_0Request {
	return ApiExtractNews_0Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *NewsApiService) ExtractNews_1Execute(r ApiExtractNews_0Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NewsApiService.ExtractNews_1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extract-news-links"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.url == nil {
		return localVarReturnValue, nil, reportError("url is required and must be specified")
	}
	if r.apiKey == nil {
		return localVarReturnValue, nil, reportError("apiKey is required and must be specified")
	}

	localVarQueryParams.Add("url", parameterToString(*r.url, ""))
	if r.prefix != nil {
		localVarQueryParams.Add("prefix", parameterToString(*r.prefix, ""))
	}
	if r.subDomain != nil {
		localVarQueryParams.Add("sub-domain", parameterToString(*r.subDomain, ""))
	}
	localVarQueryParams.Add("api-key", parameterToString(*r.apiKey, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api-key", key)
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["headerApiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGeoCoordinatesRequest struct {
	ctx context.Context
	ApiService *NewsApiService
	location *string
}

// The address or name of the location, e.g. Tokyo, Japan.
func (r ApiGeoCoordinatesRequest) Location(location string) ApiGeoCoordinatesRequest {
	r.location = &location
	return r
}

func (r ApiGeoCoordinatesRequest) Execute() (*InlineResponse2002, *http.Response, error) {
	return r.ApiService.GeoCoordinatesExecute(r)
}

/*
GeoCoordinates Get Geo Coordinates

Get the geo coordinates for a location. The location can be an exact address but also just the name of a city or country.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGeoCoordinatesRequest
*/
func (a *NewsApiService) GeoCoordinates(ctx context.Context) ApiGeoCoordinatesRequest {
	return ApiGeoCoordinatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse2002
func (a *NewsApiService) GeoCoordinatesExecute(r ApiGeoCoordinatesRequest) (*InlineResponse2002, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse2002
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NewsApiService.GeoCoordinates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/geo-coordinates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.location == nil {
		return localVarReturnValue, nil, reportError("location is required and must be specified")
	}

	localVarQueryParams.Add("location", parameterToString(*r.location, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api-key", key)
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["headerApiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiNewsWebsiteToRSSFeedRequest struct {
	ctx context.Context
	ApiService *NewsApiService
	url *string
	apiKey *string
	extractNews *bool
}

// The url from which links should be extracted.
func (r ApiNewsWebsiteToRSSFeedRequest) Url(url string) ApiNewsWebsiteToRSSFeedRequest {
	r.url = &url
	return r
}
// Your API key.
func (r ApiNewsWebsiteToRSSFeedRequest) ApiKey(apiKey string) ApiNewsWebsiteToRSSFeedRequest {
	r.apiKey = &apiKey
	return r
}
// Whether extract news and add information such as description, publish date, and image to each item.
func (r ApiNewsWebsiteToRSSFeedRequest) ExtractNews(extractNews bool) ApiNewsWebsiteToRSSFeedRequest {
	r.extractNews = &extractNews
	return r
}

func (r ApiNewsWebsiteToRSSFeedRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.NewsWebsiteToRSSFeedExecute(r)
}

/*
NewsWebsiteToRSSFeed News Website to RSS Feed

Turn a news website into an RSS feed. Any page of a news website can be turned into an RSS feed. Provide the URL to the page and the API will return an RSS feed with the latest news from that page. 

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiNewsWebsiteToRSSFeedRequest
*/
func (a *NewsApiService) NewsWebsiteToRSSFeed(ctx context.Context) ApiNewsWebsiteToRSSFeedRequest {
	return ApiNewsWebsiteToRSSFeedRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *NewsApiService) NewsWebsiteToRSSFeedExecute(r ApiNewsWebsiteToRSSFeedRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NewsApiService.NewsWebsiteToRSSFeed")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/feed.rss"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.url == nil {
		return localVarReturnValue, nil, reportError("url is required and must be specified")
	}
	if r.apiKey == nil {
		return localVarReturnValue, nil, reportError("apiKey is required and must be specified")
	}

	localVarQueryParams.Add("url", parameterToString(*r.url, ""))
	if r.extractNews != nil {
		localVarQueryParams.Add("extract-news", parameterToString(*r.extractNews, ""))
	}
	localVarQueryParams.Add("api-key", parameterToString(*r.apiKey, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"", "application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api-key", key)
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["headerApiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchNewsRequest struct {
	ctx context.Context
	ApiService *NewsApiService
	text *string
	sourceCountries *string
	language *string
	minSentiment *float64
	maxSentiment *float64
	earliestPublishDate *string
	latestPublishDate *string
	newsSources *string
	authors *string
	entities *string
	locationFilter *string
	offset *int32
	number *int32
	sort *string
	sortDirection *string
}

// The text to match in the news content.
func (r ApiSearchNewsRequest) Text(text string) ApiSearchNewsRequest {
	r.text = &text
	return r
}
// A comma-separated list of ISO 3166 country codes from which the news should originate, e.g. gb,us.
func (r ApiSearchNewsRequest) SourceCountries(sourceCountries string) ApiSearchNewsRequest {
	r.sourceCountries = &sourceCountries
	return r
}
// The ISO 6391 language code of the news, e.g. \&quot;en\&quot; for English.
func (r ApiSearchNewsRequest) Language(language string) ApiSearchNewsRequest {
	r.language = &language
	return r
}
// The minimal sentiment of the news in range [-1,1].
func (r ApiSearchNewsRequest) MinSentiment(minSentiment float64) ApiSearchNewsRequest {
	r.minSentiment = &minSentiment
	return r
}
// The maximal sentiment of the news in range [-1,1].
func (r ApiSearchNewsRequest) MaxSentiment(maxSentiment float64) ApiSearchNewsRequest {
	r.maxSentiment = &maxSentiment
	return r
}
// The news must have been published after this date.
func (r ApiSearchNewsRequest) EarliestPublishDate(earliestPublishDate string) ApiSearchNewsRequest {
	r.earliestPublishDate = &earliestPublishDate
	return r
}
// The news must have been published before this date.
func (r ApiSearchNewsRequest) LatestPublishDate(latestPublishDate string) ApiSearchNewsRequest {
	r.latestPublishDate = &latestPublishDate
	return r
}
// A comma-separated list of news sources from which the news should originate, e.g. https://www.bbc.co.uk
func (r ApiSearchNewsRequest) NewsSources(newsSources string) ApiSearchNewsRequest {
	r.newsSources = &newsSources
	return r
}
// A comma-separated list of author names. Only news from any of the given authors will be returned.
func (r ApiSearchNewsRequest) Authors(authors string) ApiSearchNewsRequest {
	r.authors = &authors
	return r
}
// Filter news by entities, e.g. ORG:Tesla.
func (r ApiSearchNewsRequest) Entities(entities string) ApiSearchNewsRequest {
	r.entities = &entities
	return r
}
// Filter news by radius around a certain location. Format is \&quot;latitude,longitude,radius in kilometers\&quot;, e.g. 51.050407, 13.737262, 100
func (r ApiSearchNewsRequest) LocationFilter(locationFilter string) ApiSearchNewsRequest {
	r.locationFilter = &locationFilter
	return r
}
// The number of news to skip in range [0,1000]
func (r ApiSearchNewsRequest) Offset(offset int32) ApiSearchNewsRequest {
	r.offset = &offset
	return r
}
// The number of news to return in range [1,100]
func (r ApiSearchNewsRequest) Number(number int32) ApiSearchNewsRequest {
	r.number = &number
	return r
}
// The sorting criteria.
func (r ApiSearchNewsRequest) Sort(sort string) ApiSearchNewsRequest {
	r.sort = &sort
	return r
}
// Whether to sort ascending or descending.
func (r ApiSearchNewsRequest) SortDirection(sortDirection string) ApiSearchNewsRequest {
	r.sortDirection = &sortDirection
	return r
}

func (r ApiSearchNewsRequest) Execute() (*InlineResponse200, *http.Response, error) {
	return r.ApiService.SearchNewsExecute(r)
}

/*
SearchNews Search News

Search for news.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchNewsRequest
*/
func (a *NewsApiService) SearchNews(ctx context.Context) ApiSearchNewsRequest {
	return ApiSearchNewsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse200
func (a *NewsApiService) SearchNewsExecute(r ApiSearchNewsRequest) (*InlineResponse200, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse200
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NewsApiService.SearchNews")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/search-news"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.text != nil {
		localVarQueryParams.Add("text", parameterToString(*r.text, ""))
	}
	if r.sourceCountries != nil {
		localVarQueryParams.Add("source-countries", parameterToString(*r.sourceCountries, ""))
	}
	if r.language != nil {
		localVarQueryParams.Add("language", parameterToString(*r.language, ""))
	}
	if r.minSentiment != nil {
		localVarQueryParams.Add("min-sentiment", parameterToString(*r.minSentiment, ""))
	}
	if r.maxSentiment != nil {
		localVarQueryParams.Add("max-sentiment", parameterToString(*r.maxSentiment, ""))
	}
	if r.earliestPublishDate != nil {
		localVarQueryParams.Add("earliest-publish-date", parameterToString(*r.earliestPublishDate, ""))
	}
	if r.latestPublishDate != nil {
		localVarQueryParams.Add("latest-publish-date", parameterToString(*r.latestPublishDate, ""))
	}
	if r.newsSources != nil {
		localVarQueryParams.Add("news-sources", parameterToString(*r.newsSources, ""))
	}
	if r.authors != nil {
		localVarQueryParams.Add("authors", parameterToString(*r.authors, ""))
	}
	if r.entities != nil {
		localVarQueryParams.Add("entities", parameterToString(*r.entities, ""))
	}
	if r.locationFilter != nil {
		localVarQueryParams.Add("location-filter", parameterToString(*r.locationFilter, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.number != nil {
		localVarQueryParams.Add("number", parameterToString(*r.number, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	if r.sortDirection != nil {
		localVarQueryParams.Add("sort-direction", parameterToString(*r.sortDirection, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api-key", key)
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["headerApiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
