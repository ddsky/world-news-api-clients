{-
   World News API

   The world's news wrapped into a single API.

   OpenAPI Version: 3.0.0
   World News API API version: 2.2.0
   Contact: mail@worldnewsapi.com
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : WorldNews.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module WorldNews.Model where

import WorldNews.Core
import WorldNews.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** Analyze
newtype Analyze = Analyze { unAnalyze :: Bool } deriving (P.Eq, P.Show)

-- ** Authors
newtype Authors = Authors { unAuthors :: Text } deriving (P.Eq, P.Show)

-- ** Categories
newtype Categories = Categories { unCategories :: Text } deriving (P.Eq, P.Show)

-- ** EarliestPublishDate
newtype EarliestPublishDate = EarliestPublishDate { unEarliestPublishDate :: Text } deriving (P.Eq, P.Show)

-- ** Entities
newtype Entities = Entities { unEntities :: Text } deriving (P.Eq, P.Show)

-- ** ExtractNews2
newtype ExtractNews2 = ExtractNews2 { unExtractNews2 :: Bool } deriving (P.Eq, P.Show)

-- ** HeadlinesOnly
newtype HeadlinesOnly = HeadlinesOnly { unHeadlinesOnly :: Bool } deriving (P.Eq, P.Show)

-- ** Ids
newtype Ids = Ids { unIds :: Text } deriving (P.Eq, P.Show)

-- ** Language
newtype Language = Language { unLanguage :: Text } deriving (P.Eq, P.Show)

-- ** LatestPublishDate
newtype LatestPublishDate = LatestPublishDate { unLatestPublishDate :: Text } deriving (P.Eq, P.Show)

-- ** Location
newtype Location = Location { unLocation :: Text } deriving (P.Eq, P.Show)

-- ** LocationFilter
newtype LocationFilter = LocationFilter { unLocationFilter :: Text } deriving (P.Eq, P.Show)

-- ** MaxSentiment
newtype MaxSentiment = MaxSentiment { unMaxSentiment :: Double } deriving (P.Eq, P.Show)

-- ** MinSentiment
newtype MinSentiment = MinSentiment { unMinSentiment :: Double } deriving (P.Eq, P.Show)

-- ** Name
newtype Name = Name { unName :: Text } deriving (P.Eq, P.Show)

-- ** NewsSources
newtype NewsSources = NewsSources { unNewsSources :: Text } deriving (P.Eq, P.Show)

-- ** Number
newtype Number = Number { unNumber :: Int } deriving (P.Eq, P.Show)

-- ** Offset
newtype Offset = Offset { unOffset :: Int } deriving (P.Eq, P.Show)

-- ** ParamDate
newtype ParamDate = ParamDate { unParamDate :: Text } deriving (P.Eq, P.Show)

-- ** ParamText
newtype ParamText = ParamText { unParamText :: Text } deriving (P.Eq, P.Show)

-- ** Sort
newtype Sort = Sort { unSort :: Text } deriving (P.Eq, P.Show)

-- ** SortDirection
newtype SortDirection = SortDirection { unSortDirection :: Text } deriving (P.Eq, P.Show)

-- ** SourceCountry
newtype SourceCountry = SourceCountry { unSourceCountry :: Text } deriving (P.Eq, P.Show)

-- ** SourceName
newtype SourceName = SourceName { unSourceName :: Text } deriving (P.Eq, P.Show)

-- ** TextMatchIndexes
newtype TextMatchIndexes = TextMatchIndexes { unTextMatchIndexes :: Text } deriving (P.Eq, P.Show)

-- ** Url
newtype Url = Url { unUrl :: Text } deriving (P.Eq, P.Show)

-- * Models


-- ** ExtractNews200Response
-- | ExtractNews200Response
data ExtractNews200Response = ExtractNews200Response
  { extractNews200ResponseTitle :: !(Maybe Text) -- ^ "title"
  , extractNews200ResponseText :: !(Maybe Text) -- ^ "text"
  , extractNews200ResponseUrl :: !(Maybe Text) -- ^ "url"
  , extractNews200ResponseImage :: !(Maybe Text) -- ^ "image"
  , extractNews200ResponseImages :: !(Maybe [ExtractNews200ResponseImagesInner]) -- ^ "images"
  , extractNews200ResponseVideo :: !(Maybe Text) -- ^ "video"
  , extractNews200ResponseVideos :: !(Maybe [ExtractNews200ResponseVideosInner]) -- ^ "videos"
  , extractNews200ResponsePublishDate :: !(Maybe Text) -- ^ "publish_date"
  , extractNews200ResponseAuthor :: !(Maybe Text) -- ^ "author"
  , extractNews200ResponseAuthors :: !(Maybe [Text]) -- ^ "authors"
  , extractNews200ResponseLanguage :: !(Maybe Text) -- ^ "language"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExtractNews200Response
instance A.FromJSON ExtractNews200Response where
  parseJSON = A.withObject "ExtractNews200Response" $ \o ->
    ExtractNews200Response
      <$> (o .:? "title")
      <*> (o .:? "text")
      <*> (o .:? "url")
      <*> (o .:? "image")
      <*> (o .:? "images")
      <*> (o .:? "video")
      <*> (o .:? "videos")
      <*> (o .:? "publish_date")
      <*> (o .:? "author")
      <*> (o .:? "authors")
      <*> (o .:? "language")

-- | ToJSON ExtractNews200Response
instance A.ToJSON ExtractNews200Response where
  toJSON ExtractNews200Response {..} =
   _omitNulls
      [ "title" .= extractNews200ResponseTitle
      , "text" .= extractNews200ResponseText
      , "url" .= extractNews200ResponseUrl
      , "image" .= extractNews200ResponseImage
      , "images" .= extractNews200ResponseImages
      , "video" .= extractNews200ResponseVideo
      , "videos" .= extractNews200ResponseVideos
      , "publish_date" .= extractNews200ResponsePublishDate
      , "author" .= extractNews200ResponseAuthor
      , "authors" .= extractNews200ResponseAuthors
      , "language" .= extractNews200ResponseLanguage
      ]


-- | Construct a value of type 'ExtractNews200Response' (by applying it's required fields, if any)
mkExtractNews200Response
  :: ExtractNews200Response
mkExtractNews200Response =
  ExtractNews200Response
  { extractNews200ResponseTitle = Nothing
  , extractNews200ResponseText = Nothing
  , extractNews200ResponseUrl = Nothing
  , extractNews200ResponseImage = Nothing
  , extractNews200ResponseImages = Nothing
  , extractNews200ResponseVideo = Nothing
  , extractNews200ResponseVideos = Nothing
  , extractNews200ResponsePublishDate = Nothing
  , extractNews200ResponseAuthor = Nothing
  , extractNews200ResponseAuthors = Nothing
  , extractNews200ResponseLanguage = Nothing
  }

-- ** ExtractNews200ResponseImagesInner
-- | ExtractNews200ResponseImagesInner
data ExtractNews200ResponseImagesInner = ExtractNews200ResponseImagesInner
  { extractNews200ResponseImagesInnerWidth :: !(Maybe Int) -- ^ "width"
  , extractNews200ResponseImagesInnerTitle :: !(Maybe Text) -- ^ "title"
  , extractNews200ResponseImagesInnerUrl :: !(Maybe Text) -- ^ "url"
  , extractNews200ResponseImagesInnerHeight :: !(Maybe Int) -- ^ "height"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExtractNews200ResponseImagesInner
instance A.FromJSON ExtractNews200ResponseImagesInner where
  parseJSON = A.withObject "ExtractNews200ResponseImagesInner" $ \o ->
    ExtractNews200ResponseImagesInner
      <$> (o .:? "width")
      <*> (o .:? "title")
      <*> (o .:? "url")
      <*> (o .:? "height")

-- | ToJSON ExtractNews200ResponseImagesInner
instance A.ToJSON ExtractNews200ResponseImagesInner where
  toJSON ExtractNews200ResponseImagesInner {..} =
   _omitNulls
      [ "width" .= extractNews200ResponseImagesInnerWidth
      , "title" .= extractNews200ResponseImagesInnerTitle
      , "url" .= extractNews200ResponseImagesInnerUrl
      , "height" .= extractNews200ResponseImagesInnerHeight
      ]


-- | Construct a value of type 'ExtractNews200ResponseImagesInner' (by applying it's required fields, if any)
mkExtractNews200ResponseImagesInner
  :: ExtractNews200ResponseImagesInner
mkExtractNews200ResponseImagesInner =
  ExtractNews200ResponseImagesInner
  { extractNews200ResponseImagesInnerWidth = Nothing
  , extractNews200ResponseImagesInnerTitle = Nothing
  , extractNews200ResponseImagesInnerUrl = Nothing
  , extractNews200ResponseImagesInnerHeight = Nothing
  }

-- ** ExtractNews200ResponseVideosInner
-- | ExtractNews200ResponseVideosInner
data ExtractNews200ResponseVideosInner = ExtractNews200ResponseVideosInner
  { extractNews200ResponseVideosInnerSummary :: !(Maybe Text) -- ^ "summary"
  , extractNews200ResponseVideosInnerDuration :: !(Maybe Int) -- ^ "duration"
  , extractNews200ResponseVideosInnerThumbnail :: !(Maybe Text) -- ^ "thumbnail"
  , extractNews200ResponseVideosInnerTitle :: !(Maybe Text) -- ^ "title"
  , extractNews200ResponseVideosInnerUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExtractNews200ResponseVideosInner
instance A.FromJSON ExtractNews200ResponseVideosInner where
  parseJSON = A.withObject "ExtractNews200ResponseVideosInner" $ \o ->
    ExtractNews200ResponseVideosInner
      <$> (o .:? "summary")
      <*> (o .:? "duration")
      <*> (o .:? "thumbnail")
      <*> (o .:? "title")
      <*> (o .:? "url")

-- | ToJSON ExtractNews200ResponseVideosInner
instance A.ToJSON ExtractNews200ResponseVideosInner where
  toJSON ExtractNews200ResponseVideosInner {..} =
   _omitNulls
      [ "summary" .= extractNews200ResponseVideosInnerSummary
      , "duration" .= extractNews200ResponseVideosInnerDuration
      , "thumbnail" .= extractNews200ResponseVideosInnerThumbnail
      , "title" .= extractNews200ResponseVideosInnerTitle
      , "url" .= extractNews200ResponseVideosInnerUrl
      ]


-- | Construct a value of type 'ExtractNews200ResponseVideosInner' (by applying it's required fields, if any)
mkExtractNews200ResponseVideosInner
  :: ExtractNews200ResponseVideosInner
mkExtractNews200ResponseVideosInner =
  ExtractNews200ResponseVideosInner
  { extractNews200ResponseVideosInnerSummary = Nothing
  , extractNews200ResponseVideosInnerDuration = Nothing
  , extractNews200ResponseVideosInnerThumbnail = Nothing
  , extractNews200ResponseVideosInnerTitle = Nothing
  , extractNews200ResponseVideosInnerUrl = Nothing
  }

-- ** ExtractNewsLinks200Response
-- | ExtractNewsLinks200Response
data ExtractNewsLinks200Response = ExtractNewsLinks200Response
  { extractNewsLinks200ResponseNewsLinks :: !(Maybe [Text]) -- ^ "news_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExtractNewsLinks200Response
instance A.FromJSON ExtractNewsLinks200Response where
  parseJSON = A.withObject "ExtractNewsLinks200Response" $ \o ->
    ExtractNewsLinks200Response
      <$> (o .:? "news_links")

-- | ToJSON ExtractNewsLinks200Response
instance A.ToJSON ExtractNewsLinks200Response where
  toJSON ExtractNewsLinks200Response {..} =
   _omitNulls
      [ "news_links" .= extractNewsLinks200ResponseNewsLinks
      ]


-- | Construct a value of type 'ExtractNewsLinks200Response' (by applying it's required fields, if any)
mkExtractNewsLinks200Response
  :: ExtractNewsLinks200Response
mkExtractNewsLinks200Response =
  ExtractNewsLinks200Response
  { extractNewsLinks200ResponseNewsLinks = Nothing
  }

-- ** GetGeoCoordinates200Response
-- | GetGeoCoordinates200Response
data GetGeoCoordinates200Response = GetGeoCoordinates200Response
  { getGeoCoordinates200ResponseLatitude :: !(Maybe Double) -- ^ "latitude"
  , getGeoCoordinates200ResponseLongitude :: !(Maybe Double) -- ^ "longitude"
  , getGeoCoordinates200ResponseCity :: !(Maybe Text) -- ^ "city"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetGeoCoordinates200Response
instance A.FromJSON GetGeoCoordinates200Response where
  parseJSON = A.withObject "GetGeoCoordinates200Response" $ \o ->
    GetGeoCoordinates200Response
      <$> (o .:? "latitude")
      <*> (o .:? "longitude")
      <*> (o .:? "city")

-- | ToJSON GetGeoCoordinates200Response
instance A.ToJSON GetGeoCoordinates200Response where
  toJSON GetGeoCoordinates200Response {..} =
   _omitNulls
      [ "latitude" .= getGeoCoordinates200ResponseLatitude
      , "longitude" .= getGeoCoordinates200ResponseLongitude
      , "city" .= getGeoCoordinates200ResponseCity
      ]


-- | Construct a value of type 'GetGeoCoordinates200Response' (by applying it's required fields, if any)
mkGetGeoCoordinates200Response
  :: GetGeoCoordinates200Response
mkGetGeoCoordinates200Response =
  GetGeoCoordinates200Response
  { getGeoCoordinates200ResponseLatitude = Nothing
  , getGeoCoordinates200ResponseLongitude = Nothing
  , getGeoCoordinates200ResponseCity = Nothing
  }

-- ** RetrieveNewsArticlesByIds200Response
-- | RetrieveNewsArticlesByIds200Response
data RetrieveNewsArticlesByIds200Response = RetrieveNewsArticlesByIds200Response
  { retrieveNewsArticlesByIds200ResponseNews :: !(Maybe [RetrieveNewsArticlesByIds200ResponseNewsInner]) -- ^ "news"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RetrieveNewsArticlesByIds200Response
instance A.FromJSON RetrieveNewsArticlesByIds200Response where
  parseJSON = A.withObject "RetrieveNewsArticlesByIds200Response" $ \o ->
    RetrieveNewsArticlesByIds200Response
      <$> (o .:? "news")

-- | ToJSON RetrieveNewsArticlesByIds200Response
instance A.ToJSON RetrieveNewsArticlesByIds200Response where
  toJSON RetrieveNewsArticlesByIds200Response {..} =
   _omitNulls
      [ "news" .= retrieveNewsArticlesByIds200ResponseNews
      ]


-- | Construct a value of type 'RetrieveNewsArticlesByIds200Response' (by applying it's required fields, if any)
mkRetrieveNewsArticlesByIds200Response
  :: RetrieveNewsArticlesByIds200Response
mkRetrieveNewsArticlesByIds200Response =
  RetrieveNewsArticlesByIds200Response
  { retrieveNewsArticlesByIds200ResponseNews = Nothing
  }

-- ** RetrieveNewsArticlesByIds200ResponseNewsInner
-- | RetrieveNewsArticlesByIds200ResponseNewsInner
data RetrieveNewsArticlesByIds200ResponseNewsInner = RetrieveNewsArticlesByIds200ResponseNewsInner
  { retrieveNewsArticlesByIds200ResponseNewsInnerSummary :: !(Maybe Text) -- ^ "summary"
  , retrieveNewsArticlesByIds200ResponseNewsInnerImage :: !(Maybe Text) -- ^ "image"
  , retrieveNewsArticlesByIds200ResponseNewsInnerSentiment :: !(Maybe Double) -- ^ "sentiment"
  , retrieveNewsArticlesByIds200ResponseNewsInnerLanguage :: !(Maybe Text) -- ^ "language"
  , retrieveNewsArticlesByIds200ResponseNewsInnerTitle :: !(Maybe Text) -- ^ "title"
  , retrieveNewsArticlesByIds200ResponseNewsInnerUrl :: !(Maybe Text) -- ^ "url"
  , retrieveNewsArticlesByIds200ResponseNewsInnerSourceCountry :: !(Maybe Text) -- ^ "source_country"
  , retrieveNewsArticlesByIds200ResponseNewsInnerId :: !(Maybe Int) -- ^ "id"
  , retrieveNewsArticlesByIds200ResponseNewsInnerText :: !(Maybe Text) -- ^ "text"
  , retrieveNewsArticlesByIds200ResponseNewsInnerCategory :: !(Maybe Text) -- ^ "category"
  , retrieveNewsArticlesByIds200ResponseNewsInnerPublishDate :: !(Maybe Text) -- ^ "publish_date"
  , retrieveNewsArticlesByIds200ResponseNewsInnerAuthors :: !(Maybe [Text]) -- ^ "authors"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RetrieveNewsArticlesByIds200ResponseNewsInner
instance A.FromJSON RetrieveNewsArticlesByIds200ResponseNewsInner where
  parseJSON = A.withObject "RetrieveNewsArticlesByIds200ResponseNewsInner" $ \o ->
    RetrieveNewsArticlesByIds200ResponseNewsInner
      <$> (o .:? "summary")
      <*> (o .:? "image")
      <*> (o .:? "sentiment")
      <*> (o .:? "language")
      <*> (o .:? "title")
      <*> (o .:? "url")
      <*> (o .:? "source_country")
      <*> (o .:? "id")
      <*> (o .:? "text")
      <*> (o .:? "category")
      <*> (o .:? "publish_date")
      <*> (o .:? "authors")

-- | ToJSON RetrieveNewsArticlesByIds200ResponseNewsInner
instance A.ToJSON RetrieveNewsArticlesByIds200ResponseNewsInner where
  toJSON RetrieveNewsArticlesByIds200ResponseNewsInner {..} =
   _omitNulls
      [ "summary" .= retrieveNewsArticlesByIds200ResponseNewsInnerSummary
      , "image" .= retrieveNewsArticlesByIds200ResponseNewsInnerImage
      , "sentiment" .= retrieveNewsArticlesByIds200ResponseNewsInnerSentiment
      , "language" .= retrieveNewsArticlesByIds200ResponseNewsInnerLanguage
      , "title" .= retrieveNewsArticlesByIds200ResponseNewsInnerTitle
      , "url" .= retrieveNewsArticlesByIds200ResponseNewsInnerUrl
      , "source_country" .= retrieveNewsArticlesByIds200ResponseNewsInnerSourceCountry
      , "id" .= retrieveNewsArticlesByIds200ResponseNewsInnerId
      , "text" .= retrieveNewsArticlesByIds200ResponseNewsInnerText
      , "category" .= retrieveNewsArticlesByIds200ResponseNewsInnerCategory
      , "publish_date" .= retrieveNewsArticlesByIds200ResponseNewsInnerPublishDate
      , "authors" .= retrieveNewsArticlesByIds200ResponseNewsInnerAuthors
      ]


-- | Construct a value of type 'RetrieveNewsArticlesByIds200ResponseNewsInner' (by applying it's required fields, if any)
mkRetrieveNewsArticlesByIds200ResponseNewsInner
  :: RetrieveNewsArticlesByIds200ResponseNewsInner
mkRetrieveNewsArticlesByIds200ResponseNewsInner =
  RetrieveNewsArticlesByIds200ResponseNewsInner
  { retrieveNewsArticlesByIds200ResponseNewsInnerSummary = Nothing
  , retrieveNewsArticlesByIds200ResponseNewsInnerImage = Nothing
  , retrieveNewsArticlesByIds200ResponseNewsInnerSentiment = Nothing
  , retrieveNewsArticlesByIds200ResponseNewsInnerLanguage = Nothing
  , retrieveNewsArticlesByIds200ResponseNewsInnerTitle = Nothing
  , retrieveNewsArticlesByIds200ResponseNewsInnerUrl = Nothing
  , retrieveNewsArticlesByIds200ResponseNewsInnerSourceCountry = Nothing
  , retrieveNewsArticlesByIds200ResponseNewsInnerId = Nothing
  , retrieveNewsArticlesByIds200ResponseNewsInnerText = Nothing
  , retrieveNewsArticlesByIds200ResponseNewsInnerCategory = Nothing
  , retrieveNewsArticlesByIds200ResponseNewsInnerPublishDate = Nothing
  , retrieveNewsArticlesByIds200ResponseNewsInnerAuthors = Nothing
  }

-- ** RetrieveNewspaperFrontPage200Response
-- | RetrieveNewspaperFrontPage200Response
data RetrieveNewspaperFrontPage200Response = RetrieveNewspaperFrontPage200Response
  { retrieveNewspaperFrontPage200ResponseFrontPage :: !(Maybe RetrieveNewspaperFrontPage200ResponseFrontPage) -- ^ "front_page"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RetrieveNewspaperFrontPage200Response
instance A.FromJSON RetrieveNewspaperFrontPage200Response where
  parseJSON = A.withObject "RetrieveNewspaperFrontPage200Response" $ \o ->
    RetrieveNewspaperFrontPage200Response
      <$> (o .:? "front_page")

-- | ToJSON RetrieveNewspaperFrontPage200Response
instance A.ToJSON RetrieveNewspaperFrontPage200Response where
  toJSON RetrieveNewspaperFrontPage200Response {..} =
   _omitNulls
      [ "front_page" .= retrieveNewspaperFrontPage200ResponseFrontPage
      ]


-- | Construct a value of type 'RetrieveNewspaperFrontPage200Response' (by applying it's required fields, if any)
mkRetrieveNewspaperFrontPage200Response
  :: RetrieveNewspaperFrontPage200Response
mkRetrieveNewspaperFrontPage200Response =
  RetrieveNewspaperFrontPage200Response
  { retrieveNewspaperFrontPage200ResponseFrontPage = Nothing
  }

-- ** RetrieveNewspaperFrontPage200ResponseFrontPage
-- | RetrieveNewspaperFrontPage200ResponseFrontPage
data RetrieveNewspaperFrontPage200ResponseFrontPage = RetrieveNewspaperFrontPage200ResponseFrontPage
  { retrieveNewspaperFrontPage200ResponseFrontPageName :: !(Maybe Text) -- ^ "name"
  , retrieveNewspaperFrontPage200ResponseFrontPageDate :: !(Maybe Text) -- ^ "date"
  , retrieveNewspaperFrontPage200ResponseFrontPageCountry :: !(Maybe Text) -- ^ "country"
  , retrieveNewspaperFrontPage200ResponseFrontPageImage :: !(Maybe Text) -- ^ "image"
  , retrieveNewspaperFrontPage200ResponseFrontPageLanguage :: !(Maybe Text) -- ^ "language"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RetrieveNewspaperFrontPage200ResponseFrontPage
instance A.FromJSON RetrieveNewspaperFrontPage200ResponseFrontPage where
  parseJSON = A.withObject "RetrieveNewspaperFrontPage200ResponseFrontPage" $ \o ->
    RetrieveNewspaperFrontPage200ResponseFrontPage
      <$> (o .:? "name")
      <*> (o .:? "date")
      <*> (o .:? "country")
      <*> (o .:? "image")
      <*> (o .:? "language")

-- | ToJSON RetrieveNewspaperFrontPage200ResponseFrontPage
instance A.ToJSON RetrieveNewspaperFrontPage200ResponseFrontPage where
  toJSON RetrieveNewspaperFrontPage200ResponseFrontPage {..} =
   _omitNulls
      [ "name" .= retrieveNewspaperFrontPage200ResponseFrontPageName
      , "date" .= retrieveNewspaperFrontPage200ResponseFrontPageDate
      , "country" .= retrieveNewspaperFrontPage200ResponseFrontPageCountry
      , "image" .= retrieveNewspaperFrontPage200ResponseFrontPageImage
      , "language" .= retrieveNewspaperFrontPage200ResponseFrontPageLanguage
      ]


-- | Construct a value of type 'RetrieveNewspaperFrontPage200ResponseFrontPage' (by applying it's required fields, if any)
mkRetrieveNewspaperFrontPage200ResponseFrontPage
  :: RetrieveNewspaperFrontPage200ResponseFrontPage
mkRetrieveNewspaperFrontPage200ResponseFrontPage =
  RetrieveNewspaperFrontPage200ResponseFrontPage
  { retrieveNewspaperFrontPage200ResponseFrontPageName = Nothing
  , retrieveNewspaperFrontPage200ResponseFrontPageDate = Nothing
  , retrieveNewspaperFrontPage200ResponseFrontPageCountry = Nothing
  , retrieveNewspaperFrontPage200ResponseFrontPageImage = Nothing
  , retrieveNewspaperFrontPage200ResponseFrontPageLanguage = Nothing
  }

-- ** SearchNews200Response
-- | SearchNews200Response
data SearchNews200Response = SearchNews200Response
  { searchNews200ResponseOffset :: !(Maybe Int) -- ^ "offset"
  , searchNews200ResponseNumber :: !(Maybe Int) -- ^ "number"
  , searchNews200ResponseAvailable :: !(Maybe Int) -- ^ "available"
  , searchNews200ResponseNews :: !(Maybe [SearchNews200ResponseNewsInner]) -- ^ "news"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchNews200Response
instance A.FromJSON SearchNews200Response where
  parseJSON = A.withObject "SearchNews200Response" $ \o ->
    SearchNews200Response
      <$> (o .:? "offset")
      <*> (o .:? "number")
      <*> (o .:? "available")
      <*> (o .:? "news")

-- | ToJSON SearchNews200Response
instance A.ToJSON SearchNews200Response where
  toJSON SearchNews200Response {..} =
   _omitNulls
      [ "offset" .= searchNews200ResponseOffset
      , "number" .= searchNews200ResponseNumber
      , "available" .= searchNews200ResponseAvailable
      , "news" .= searchNews200ResponseNews
      ]


-- | Construct a value of type 'SearchNews200Response' (by applying it's required fields, if any)
mkSearchNews200Response
  :: SearchNews200Response
mkSearchNews200Response =
  SearchNews200Response
  { searchNews200ResponseOffset = Nothing
  , searchNews200ResponseNumber = Nothing
  , searchNews200ResponseAvailable = Nothing
  , searchNews200ResponseNews = Nothing
  }

-- ** SearchNews200ResponseNewsInner
-- | SearchNews200ResponseNewsInner
data SearchNews200ResponseNewsInner = SearchNews200ResponseNewsInner
  { searchNews200ResponseNewsInnerSummary :: !(Maybe Text) -- ^ "summary"
  , searchNews200ResponseNewsInnerImage :: !(Maybe Text) -- ^ "image"
  , searchNews200ResponseNewsInnerSentiment :: !(Maybe Double) -- ^ "sentiment"
  , searchNews200ResponseNewsInnerLanguage :: !(Maybe Text) -- ^ "language"
  , searchNews200ResponseNewsInnerVideo :: !(Maybe Text) -- ^ "video"
  , searchNews200ResponseNewsInnerTitle :: !(Maybe Text) -- ^ "title"
  , searchNews200ResponseNewsInnerUrl :: !(Maybe Text) -- ^ "url"
  , searchNews200ResponseNewsInnerSourceCountry :: !(Maybe Text) -- ^ "source_country"
  , searchNews200ResponseNewsInnerId :: !(Maybe Int) -- ^ "id"
  , searchNews200ResponseNewsInnerText :: !(Maybe Text) -- ^ "text"
  , searchNews200ResponseNewsInnerCategory :: !(Maybe Text) -- ^ "category"
  , searchNews200ResponseNewsInnerPublishDate :: !(Maybe Text) -- ^ "publish_date"
  , searchNews200ResponseNewsInnerAuthors :: !(Maybe [Text]) -- ^ "authors"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchNews200ResponseNewsInner
instance A.FromJSON SearchNews200ResponseNewsInner where
  parseJSON = A.withObject "SearchNews200ResponseNewsInner" $ \o ->
    SearchNews200ResponseNewsInner
      <$> (o .:? "summary")
      <*> (o .:? "image")
      <*> (o .:? "sentiment")
      <*> (o .:? "language")
      <*> (o .:? "video")
      <*> (o .:? "title")
      <*> (o .:? "url")
      <*> (o .:? "source_country")
      <*> (o .:? "id")
      <*> (o .:? "text")
      <*> (o .:? "category")
      <*> (o .:? "publish_date")
      <*> (o .:? "authors")

-- | ToJSON SearchNews200ResponseNewsInner
instance A.ToJSON SearchNews200ResponseNewsInner where
  toJSON SearchNews200ResponseNewsInner {..} =
   _omitNulls
      [ "summary" .= searchNews200ResponseNewsInnerSummary
      , "image" .= searchNews200ResponseNewsInnerImage
      , "sentiment" .= searchNews200ResponseNewsInnerSentiment
      , "language" .= searchNews200ResponseNewsInnerLanguage
      , "video" .= searchNews200ResponseNewsInnerVideo
      , "title" .= searchNews200ResponseNewsInnerTitle
      , "url" .= searchNews200ResponseNewsInnerUrl
      , "source_country" .= searchNews200ResponseNewsInnerSourceCountry
      , "id" .= searchNews200ResponseNewsInnerId
      , "text" .= searchNews200ResponseNewsInnerText
      , "category" .= searchNews200ResponseNewsInnerCategory
      , "publish_date" .= searchNews200ResponseNewsInnerPublishDate
      , "authors" .= searchNews200ResponseNewsInnerAuthors
      ]


-- | Construct a value of type 'SearchNews200ResponseNewsInner' (by applying it's required fields, if any)
mkSearchNews200ResponseNewsInner
  :: SearchNews200ResponseNewsInner
mkSearchNews200ResponseNewsInner =
  SearchNews200ResponseNewsInner
  { searchNews200ResponseNewsInnerSummary = Nothing
  , searchNews200ResponseNewsInnerImage = Nothing
  , searchNews200ResponseNewsInnerSentiment = Nothing
  , searchNews200ResponseNewsInnerLanguage = Nothing
  , searchNews200ResponseNewsInnerVideo = Nothing
  , searchNews200ResponseNewsInnerTitle = Nothing
  , searchNews200ResponseNewsInnerUrl = Nothing
  , searchNews200ResponseNewsInnerSourceCountry = Nothing
  , searchNews200ResponseNewsInnerId = Nothing
  , searchNews200ResponseNewsInnerText = Nothing
  , searchNews200ResponseNewsInnerCategory = Nothing
  , searchNews200ResponseNewsInnerPublishDate = Nothing
  , searchNews200ResponseNewsInnerAuthors = Nothing
  }

-- ** SearchNewsSources200Response
-- | SearchNewsSources200Response
data SearchNewsSources200Response = SearchNewsSources200Response
  { searchNewsSources200ResponseAvailable :: !(Maybe Int) -- ^ "available"
  , searchNewsSources200ResponseSources :: !(Maybe [SearchNewsSources200ResponseSourcesInner]) -- ^ "sources"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchNewsSources200Response
instance A.FromJSON SearchNewsSources200Response where
  parseJSON = A.withObject "SearchNewsSources200Response" $ \o ->
    SearchNewsSources200Response
      <$> (o .:? "available")
      <*> (o .:? "sources")

-- | ToJSON SearchNewsSources200Response
instance A.ToJSON SearchNewsSources200Response where
  toJSON SearchNewsSources200Response {..} =
   _omitNulls
      [ "available" .= searchNewsSources200ResponseAvailable
      , "sources" .= searchNewsSources200ResponseSources
      ]


-- | Construct a value of type 'SearchNewsSources200Response' (by applying it's required fields, if any)
mkSearchNewsSources200Response
  :: SearchNewsSources200Response
mkSearchNewsSources200Response =
  SearchNewsSources200Response
  { searchNewsSources200ResponseAvailable = Nothing
  , searchNewsSources200ResponseSources = Nothing
  }

-- ** SearchNewsSources200ResponseSourcesInner
-- | SearchNewsSources200ResponseSourcesInner
data SearchNewsSources200ResponseSourcesInner = SearchNewsSources200ResponseSourcesInner
  { searchNewsSources200ResponseSourcesInnerName :: !(Maybe Text) -- ^ "name"
  , searchNewsSources200ResponseSourcesInnerUrl :: !(Maybe Text) -- ^ "url"
  , searchNewsSources200ResponseSourcesInnerLanguage :: !(Maybe Text) -- ^ "language"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchNewsSources200ResponseSourcesInner
instance A.FromJSON SearchNewsSources200ResponseSourcesInner where
  parseJSON = A.withObject "SearchNewsSources200ResponseSourcesInner" $ \o ->
    SearchNewsSources200ResponseSourcesInner
      <$> (o .:? "name")
      <*> (o .:? "url")
      <*> (o .:? "language")

-- | ToJSON SearchNewsSources200ResponseSourcesInner
instance A.ToJSON SearchNewsSources200ResponseSourcesInner where
  toJSON SearchNewsSources200ResponseSourcesInner {..} =
   _omitNulls
      [ "name" .= searchNewsSources200ResponseSourcesInnerName
      , "url" .= searchNewsSources200ResponseSourcesInnerUrl
      , "language" .= searchNewsSources200ResponseSourcesInnerLanguage
      ]


-- | Construct a value of type 'SearchNewsSources200ResponseSourcesInner' (by applying it's required fields, if any)
mkSearchNewsSources200ResponseSourcesInner
  :: SearchNewsSources200ResponseSourcesInner
mkSearchNewsSources200ResponseSourcesInner =
  SearchNewsSources200ResponseSourcesInner
  { searchNewsSources200ResponseSourcesInnerName = Nothing
  , searchNewsSources200ResponseSourcesInnerUrl = Nothing
  , searchNewsSources200ResponseSourcesInnerLanguage = Nothing
  }

-- ** TopNews200Response
-- | TopNews200Response
data TopNews200Response = TopNews200Response
  { topNews200ResponseTopNews :: !(Maybe [TopNews200ResponseTopNewsInner]) -- ^ "top_news"
  , topNews200ResponseLanguage :: !(Maybe Text) -- ^ "language"
  , topNews200ResponseCountry :: !(Maybe Text) -- ^ "country"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TopNews200Response
instance A.FromJSON TopNews200Response where
  parseJSON = A.withObject "TopNews200Response" $ \o ->
    TopNews200Response
      <$> (o .:? "top_news")
      <*> (o .:? "language")
      <*> (o .:? "country")

-- | ToJSON TopNews200Response
instance A.ToJSON TopNews200Response where
  toJSON TopNews200Response {..} =
   _omitNulls
      [ "top_news" .= topNews200ResponseTopNews
      , "language" .= topNews200ResponseLanguage
      , "country" .= topNews200ResponseCountry
      ]


-- | Construct a value of type 'TopNews200Response' (by applying it's required fields, if any)
mkTopNews200Response
  :: TopNews200Response
mkTopNews200Response =
  TopNews200Response
  { topNews200ResponseTopNews = Nothing
  , topNews200ResponseLanguage = Nothing
  , topNews200ResponseCountry = Nothing
  }

-- ** TopNews200ResponseTopNewsInner
-- | TopNews200ResponseTopNewsInner
data TopNews200ResponseTopNewsInner = TopNews200ResponseTopNewsInner
  { topNews200ResponseTopNewsInnerNews :: !(Maybe [TopNews200ResponseTopNewsInnerNewsInner]) -- ^ "news"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TopNews200ResponseTopNewsInner
instance A.FromJSON TopNews200ResponseTopNewsInner where
  parseJSON = A.withObject "TopNews200ResponseTopNewsInner" $ \o ->
    TopNews200ResponseTopNewsInner
      <$> (o .:? "news")

-- | ToJSON TopNews200ResponseTopNewsInner
instance A.ToJSON TopNews200ResponseTopNewsInner where
  toJSON TopNews200ResponseTopNewsInner {..} =
   _omitNulls
      [ "news" .= topNews200ResponseTopNewsInnerNews
      ]


-- | Construct a value of type 'TopNews200ResponseTopNewsInner' (by applying it's required fields, if any)
mkTopNews200ResponseTopNewsInner
  :: TopNews200ResponseTopNewsInner
mkTopNews200ResponseTopNewsInner =
  TopNews200ResponseTopNewsInner
  { topNews200ResponseTopNewsInnerNews = Nothing
  }

-- ** TopNews200ResponseTopNewsInnerNewsInner
-- | TopNews200ResponseTopNewsInnerNewsInner
data TopNews200ResponseTopNewsInnerNewsInner = TopNews200ResponseTopNewsInnerNewsInner
  { topNews200ResponseTopNewsInnerNewsInnerSummary :: !(Maybe Text) -- ^ "summary"
  , topNews200ResponseTopNewsInnerNewsInnerImage :: !(Maybe Text) -- ^ "image"
  , topNews200ResponseTopNewsInnerNewsInnerAuthor :: !(Maybe Text) -- ^ "author"
  , topNews200ResponseTopNewsInnerNewsInnerId :: !(Maybe Int) -- ^ "id"
  , topNews200ResponseTopNewsInnerNewsInnerText :: !(Maybe Text) -- ^ "text"
  , topNews200ResponseTopNewsInnerNewsInnerTitle :: !(Maybe Text) -- ^ "title"
  , topNews200ResponseTopNewsInnerNewsInnerPublishDate :: !(Maybe Text) -- ^ "publish_date"
  , topNews200ResponseTopNewsInnerNewsInnerUrl :: !(Maybe Text) -- ^ "url"
  , topNews200ResponseTopNewsInnerNewsInnerAuthors :: !(Maybe [Text]) -- ^ "authors"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TopNews200ResponseTopNewsInnerNewsInner
instance A.FromJSON TopNews200ResponseTopNewsInnerNewsInner where
  parseJSON = A.withObject "TopNews200ResponseTopNewsInnerNewsInner" $ \o ->
    TopNews200ResponseTopNewsInnerNewsInner
      <$> (o .:? "summary")
      <*> (o .:? "image")
      <*> (o .:? "author")
      <*> (o .:? "id")
      <*> (o .:? "text")
      <*> (o .:? "title")
      <*> (o .:? "publish_date")
      <*> (o .:? "url")
      <*> (o .:? "authors")

-- | ToJSON TopNews200ResponseTopNewsInnerNewsInner
instance A.ToJSON TopNews200ResponseTopNewsInnerNewsInner where
  toJSON TopNews200ResponseTopNewsInnerNewsInner {..} =
   _omitNulls
      [ "summary" .= topNews200ResponseTopNewsInnerNewsInnerSummary
      , "image" .= topNews200ResponseTopNewsInnerNewsInnerImage
      , "author" .= topNews200ResponseTopNewsInnerNewsInnerAuthor
      , "id" .= topNews200ResponseTopNewsInnerNewsInnerId
      , "text" .= topNews200ResponseTopNewsInnerNewsInnerText
      , "title" .= topNews200ResponseTopNewsInnerNewsInnerTitle
      , "publish_date" .= topNews200ResponseTopNewsInnerNewsInnerPublishDate
      , "url" .= topNews200ResponseTopNewsInnerNewsInnerUrl
      , "authors" .= topNews200ResponseTopNewsInnerNewsInnerAuthors
      ]


-- | Construct a value of type 'TopNews200ResponseTopNewsInnerNewsInner' (by applying it's required fields, if any)
mkTopNews200ResponseTopNewsInnerNewsInner
  :: TopNews200ResponseTopNewsInnerNewsInner
mkTopNews200ResponseTopNewsInnerNewsInner =
  TopNews200ResponseTopNewsInnerNewsInner
  { topNews200ResponseTopNewsInnerNewsInnerSummary = Nothing
  , topNews200ResponseTopNewsInnerNewsInnerImage = Nothing
  , topNews200ResponseTopNewsInnerNewsInnerAuthor = Nothing
  , topNews200ResponseTopNewsInnerNewsInnerId = Nothing
  , topNews200ResponseTopNewsInnerNewsInnerText = Nothing
  , topNews200ResponseTopNewsInnerNewsInnerTitle = Nothing
  , topNews200ResponseTopNewsInnerNewsInnerPublishDate = Nothing
  , topNews200ResponseTopNewsInnerNewsInnerUrl = Nothing
  , topNews200ResponseTopNewsInnerNewsInnerAuthors = Nothing
  }




-- * Auth Methods

-- ** AuthApiKeyApiKey
data AuthApiKeyApiKey =
  AuthApiKeyApiKey Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeyApiKey where
  applyAuthMethod _ a@(AuthApiKeyApiKey secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setQuery` toQuery ("api-key", Just secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req

-- ** AuthApiKeyHeaderApiKey
data AuthApiKeyHeaderApiKey =
  AuthApiKeyHeaderApiKey Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeyHeaderApiKey where
  applyAuthMethod _ a@(AuthApiKeyHeaderApiKey secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("x-api-key", secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req


