{-
   World News API

   The world's news wrapped into a single API.

   OpenAPI Version: 3.0.0
   World News API API version: 1.1.1
   Contact: mail@worldnewsapi.com
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : WorldNews.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module WorldNews.Model where

import WorldNews.Core
import WorldNews.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** Analyze
newtype Analyze = Analyze { unAnalyze :: Bool } deriving (P.Eq, P.Show)

-- ** Authors
newtype Authors = Authors { unAuthors :: Text } deriving (P.Eq, P.Show)

-- ** EarliestPublishDate
newtype EarliestPublishDate = EarliestPublishDate { unEarliestPublishDate :: Text } deriving (P.Eq, P.Show)

-- ** Entities
newtype Entities = Entities { unEntities :: Text } deriving (P.Eq, P.Show)

-- ** HeadlinesOnly
newtype HeadlinesOnly = HeadlinesOnly { unHeadlinesOnly :: Bool } deriving (P.Eq, P.Show)

-- ** Language
newtype Language = Language { unLanguage :: Text } deriving (P.Eq, P.Show)

-- ** LatestPublishDate
newtype LatestPublishDate = LatestPublishDate { unLatestPublishDate :: Text } deriving (P.Eq, P.Show)

-- ** Location
newtype Location = Location { unLocation :: Text } deriving (P.Eq, P.Show)

-- ** LocationFilter
newtype LocationFilter = LocationFilter { unLocationFilter :: Text } deriving (P.Eq, P.Show)

-- ** MaxSentiment
newtype MaxSentiment = MaxSentiment { unMaxSentiment :: Double } deriving (P.Eq, P.Show)

-- ** MinSentiment
newtype MinSentiment = MinSentiment { unMinSentiment :: Double } deriving (P.Eq, P.Show)

-- ** NewsSources
newtype NewsSources = NewsSources { unNewsSources :: Text } deriving (P.Eq, P.Show)

-- ** Number
newtype Number = Number { unNumber :: Int } deriving (P.Eq, P.Show)

-- ** Offset
newtype Offset = Offset { unOffset :: Int } deriving (P.Eq, P.Show)

-- ** ParamDate
newtype ParamDate = ParamDate { unParamDate :: Text } deriving (P.Eq, P.Show)

-- ** ParamText
newtype ParamText = ParamText { unParamText :: Text } deriving (P.Eq, P.Show)

-- ** Sort
newtype Sort = Sort { unSort :: Text } deriving (P.Eq, P.Show)

-- ** SortDirection
newtype SortDirection = SortDirection { unSortDirection :: Text } deriving (P.Eq, P.Show)

-- ** SourceCountries
newtype SourceCountries = SourceCountries { unSourceCountries :: Text } deriving (P.Eq, P.Show)

-- ** SourceCountry
newtype SourceCountry = SourceCountry { unSourceCountry :: Text } deriving (P.Eq, P.Show)

-- ** Url
newtype Url = Url { unUrl :: Text } deriving (P.Eq, P.Show)

-- * Models


-- ** ExtractNews200Response
-- | ExtractNews200Response
data ExtractNews200Response = ExtractNews200Response
  { extractNews200ResponseTitle :: !(Maybe Text) -- ^ "title"
  , extractNews200ResponseText :: !(Maybe Text) -- ^ "text"
  , extractNews200ResponseUrl :: !(Maybe Text) -- ^ "url"
  , extractNews200ResponseImage :: !(Maybe Text) -- ^ "image"
  , extractNews200ResponsePublishDate :: !(Maybe Text) -- ^ "publish_date"
  , extractNews200ResponseAuthor :: !(Maybe Text) -- ^ "author"
  , extractNews200ResponseLanguage :: !(Maybe Text) -- ^ "language"
  , extractNews200ResponseSourceCountry :: !(Maybe Text) -- ^ "source_country"
  , extractNews200ResponseSentiment :: !(Maybe Double) -- ^ "sentiment"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExtractNews200Response
instance A.FromJSON ExtractNews200Response where
  parseJSON = A.withObject "ExtractNews200Response" $ \o ->
    ExtractNews200Response
      <$> (o .:? "title")
      <*> (o .:? "text")
      <*> (o .:? "url")
      <*> (o .:? "image")
      <*> (o .:? "publish_date")
      <*> (o .:? "author")
      <*> (o .:? "language")
      <*> (o .:? "source_country")
      <*> (o .:? "sentiment")

-- | ToJSON ExtractNews200Response
instance A.ToJSON ExtractNews200Response where
  toJSON ExtractNews200Response {..} =
   _omitNulls
      [ "title" .= extractNews200ResponseTitle
      , "text" .= extractNews200ResponseText
      , "url" .= extractNews200ResponseUrl
      , "image" .= extractNews200ResponseImage
      , "publish_date" .= extractNews200ResponsePublishDate
      , "author" .= extractNews200ResponseAuthor
      , "language" .= extractNews200ResponseLanguage
      , "source_country" .= extractNews200ResponseSourceCountry
      , "sentiment" .= extractNews200ResponseSentiment
      ]


-- | Construct a value of type 'ExtractNews200Response' (by applying it's required fields, if any)
mkExtractNews200Response
  :: ExtractNews200Response
mkExtractNews200Response =
  ExtractNews200Response
  { extractNews200ResponseTitle = Nothing
  , extractNews200ResponseText = Nothing
  , extractNews200ResponseUrl = Nothing
  , extractNews200ResponseImage = Nothing
  , extractNews200ResponsePublishDate = Nothing
  , extractNews200ResponseAuthor = Nothing
  , extractNews200ResponseLanguage = Nothing
  , extractNews200ResponseSourceCountry = Nothing
  , extractNews200ResponseSentiment = Nothing
  }

-- ** ExtractNewsLinks200Response
-- | ExtractNewsLinks200Response
data ExtractNewsLinks200Response = ExtractNewsLinks200Response
  { extractNewsLinks200ResponseNewsLinks :: !(Maybe [Text]) -- ^ "news_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExtractNewsLinks200Response
instance A.FromJSON ExtractNewsLinks200Response where
  parseJSON = A.withObject "ExtractNewsLinks200Response" $ \o ->
    ExtractNewsLinks200Response
      <$> (o .:? "news_links")

-- | ToJSON ExtractNewsLinks200Response
instance A.ToJSON ExtractNewsLinks200Response where
  toJSON ExtractNewsLinks200Response {..} =
   _omitNulls
      [ "news_links" .= extractNewsLinks200ResponseNewsLinks
      ]


-- | Construct a value of type 'ExtractNewsLinks200Response' (by applying it's required fields, if any)
mkExtractNewsLinks200Response
  :: ExtractNewsLinks200Response
mkExtractNewsLinks200Response =
  ExtractNewsLinks200Response
  { extractNewsLinks200ResponseNewsLinks = Nothing
  }

-- ** GetGeoCoordinates200Response
-- | GetGeoCoordinates200Response
data GetGeoCoordinates200Response = GetGeoCoordinates200Response
  { getGeoCoordinates200ResponseLatitude :: !(Maybe Double) -- ^ "latitude"
  , getGeoCoordinates200ResponseLongitude :: !(Maybe Double) -- ^ "longitude"
  , getGeoCoordinates200ResponseCity :: !(Maybe Text) -- ^ "city"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetGeoCoordinates200Response
instance A.FromJSON GetGeoCoordinates200Response where
  parseJSON = A.withObject "GetGeoCoordinates200Response" $ \o ->
    GetGeoCoordinates200Response
      <$> (o .:? "latitude")
      <*> (o .:? "longitude")
      <*> (o .:? "city")

-- | ToJSON GetGeoCoordinates200Response
instance A.ToJSON GetGeoCoordinates200Response where
  toJSON GetGeoCoordinates200Response {..} =
   _omitNulls
      [ "latitude" .= getGeoCoordinates200ResponseLatitude
      , "longitude" .= getGeoCoordinates200ResponseLongitude
      , "city" .= getGeoCoordinates200ResponseCity
      ]


-- | Construct a value of type 'GetGeoCoordinates200Response' (by applying it's required fields, if any)
mkGetGeoCoordinates200Response
  :: GetGeoCoordinates200Response
mkGetGeoCoordinates200Response =
  GetGeoCoordinates200Response
  { getGeoCoordinates200ResponseLatitude = Nothing
  , getGeoCoordinates200ResponseLongitude = Nothing
  , getGeoCoordinates200ResponseCity = Nothing
  }

-- ** SearchNews200Response
-- | SearchNews200Response
data SearchNews200Response = SearchNews200Response
  { searchNews200ResponseOffset :: !(Maybe Int) -- ^ "offset"
  , searchNews200ResponseNumber :: !(Maybe Int) -- ^ "number"
  , searchNews200ResponseAvailable :: !(Maybe Int) -- ^ "available"
  , searchNews200ResponseNews :: !(Maybe [SearchNews200ResponseNewsInner]) -- ^ "news"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchNews200Response
instance A.FromJSON SearchNews200Response where
  parseJSON = A.withObject "SearchNews200Response" $ \o ->
    SearchNews200Response
      <$> (o .:? "offset")
      <*> (o .:? "number")
      <*> (o .:? "available")
      <*> (o .:? "news")

-- | ToJSON SearchNews200Response
instance A.ToJSON SearchNews200Response where
  toJSON SearchNews200Response {..} =
   _omitNulls
      [ "offset" .= searchNews200ResponseOffset
      , "number" .= searchNews200ResponseNumber
      , "available" .= searchNews200ResponseAvailable
      , "news" .= searchNews200ResponseNews
      ]


-- | Construct a value of type 'SearchNews200Response' (by applying it's required fields, if any)
mkSearchNews200Response
  :: SearchNews200Response
mkSearchNews200Response =
  SearchNews200Response
  { searchNews200ResponseOffset = Nothing
  , searchNews200ResponseNumber = Nothing
  , searchNews200ResponseAvailable = Nothing
  , searchNews200ResponseNews = Nothing
  }

-- ** SearchNews200ResponseNewsInner
-- | SearchNews200ResponseNewsInner
data SearchNews200ResponseNewsInner = SearchNews200ResponseNewsInner
  { searchNews200ResponseNewsInnerSummary :: !(Maybe Text) -- ^ "summary"
  , searchNews200ResponseNewsInnerImage :: !(Maybe Text) -- ^ "image"
  , searchNews200ResponseNewsInnerSentiment :: !(Maybe Double) -- ^ "sentiment"
  , searchNews200ResponseNewsInnerSourceCountry :: !(Maybe Text) -- ^ "source_country"
  , searchNews200ResponseNewsInnerLanguage :: !(Maybe Text) -- ^ "language"
  , searchNews200ResponseNewsInnerId :: !(Maybe Int) -- ^ "id"
  , searchNews200ResponseNewsInnerText :: !(Maybe Text) -- ^ "text"
  , searchNews200ResponseNewsInnerTitle :: !(Maybe Text) -- ^ "title"
  , searchNews200ResponseNewsInnerPublishDate :: !(Maybe Text) -- ^ "publish_date"
  , searchNews200ResponseNewsInnerUrl :: !(Maybe Text) -- ^ "url"
  , searchNews200ResponseNewsInnerAuthors :: !(Maybe [Text]) -- ^ "authors"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SearchNews200ResponseNewsInner
instance A.FromJSON SearchNews200ResponseNewsInner where
  parseJSON = A.withObject "SearchNews200ResponseNewsInner" $ \o ->
    SearchNews200ResponseNewsInner
      <$> (o .:? "summary")
      <*> (o .:? "image")
      <*> (o .:? "sentiment")
      <*> (o .:? "source_country")
      <*> (o .:? "language")
      <*> (o .:? "id")
      <*> (o .:? "text")
      <*> (o .:? "title")
      <*> (o .:? "publish_date")
      <*> (o .:? "url")
      <*> (o .:? "authors")

-- | ToJSON SearchNews200ResponseNewsInner
instance A.ToJSON SearchNews200ResponseNewsInner where
  toJSON SearchNews200ResponseNewsInner {..} =
   _omitNulls
      [ "summary" .= searchNews200ResponseNewsInnerSummary
      , "image" .= searchNews200ResponseNewsInnerImage
      , "sentiment" .= searchNews200ResponseNewsInnerSentiment
      , "source_country" .= searchNews200ResponseNewsInnerSourceCountry
      , "language" .= searchNews200ResponseNewsInnerLanguage
      , "id" .= searchNews200ResponseNewsInnerId
      , "text" .= searchNews200ResponseNewsInnerText
      , "title" .= searchNews200ResponseNewsInnerTitle
      , "publish_date" .= searchNews200ResponseNewsInnerPublishDate
      , "url" .= searchNews200ResponseNewsInnerUrl
      , "authors" .= searchNews200ResponseNewsInnerAuthors
      ]


-- | Construct a value of type 'SearchNews200ResponseNewsInner' (by applying it's required fields, if any)
mkSearchNews200ResponseNewsInner
  :: SearchNews200ResponseNewsInner
mkSearchNews200ResponseNewsInner =
  SearchNews200ResponseNewsInner
  { searchNews200ResponseNewsInnerSummary = Nothing
  , searchNews200ResponseNewsInnerImage = Nothing
  , searchNews200ResponseNewsInnerSentiment = Nothing
  , searchNews200ResponseNewsInnerSourceCountry = Nothing
  , searchNews200ResponseNewsInnerLanguage = Nothing
  , searchNews200ResponseNewsInnerId = Nothing
  , searchNews200ResponseNewsInnerText = Nothing
  , searchNews200ResponseNewsInnerTitle = Nothing
  , searchNews200ResponseNewsInnerPublishDate = Nothing
  , searchNews200ResponseNewsInnerUrl = Nothing
  , searchNews200ResponseNewsInnerAuthors = Nothing
  }

-- ** TopNews200Response
-- | TopNews200Response
data TopNews200Response = TopNews200Response
  { topNews200ResponseTopNews :: !(Maybe [TopNews200ResponseTopNewsInner]) -- ^ "top_news"
  , topNews200ResponseLanguage :: !(Maybe Text) -- ^ "language"
  , topNews200ResponseCountry :: !(Maybe Text) -- ^ "country"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TopNews200Response
instance A.FromJSON TopNews200Response where
  parseJSON = A.withObject "TopNews200Response" $ \o ->
    TopNews200Response
      <$> (o .:? "top_news")
      <*> (o .:? "language")
      <*> (o .:? "country")

-- | ToJSON TopNews200Response
instance A.ToJSON TopNews200Response where
  toJSON TopNews200Response {..} =
   _omitNulls
      [ "top_news" .= topNews200ResponseTopNews
      , "language" .= topNews200ResponseLanguage
      , "country" .= topNews200ResponseCountry
      ]


-- | Construct a value of type 'TopNews200Response' (by applying it's required fields, if any)
mkTopNews200Response
  :: TopNews200Response
mkTopNews200Response =
  TopNews200Response
  { topNews200ResponseTopNews = Nothing
  , topNews200ResponseLanguage = Nothing
  , topNews200ResponseCountry = Nothing
  }

-- ** TopNews200ResponseTopNewsInner
-- | TopNews200ResponseTopNewsInner
data TopNews200ResponseTopNewsInner = TopNews200ResponseTopNewsInner
  { topNews200ResponseTopNewsInnerNews :: !(Maybe [TopNews200ResponseTopNewsInnerNewsInner]) -- ^ "news"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TopNews200ResponseTopNewsInner
instance A.FromJSON TopNews200ResponseTopNewsInner where
  parseJSON = A.withObject "TopNews200ResponseTopNewsInner" $ \o ->
    TopNews200ResponseTopNewsInner
      <$> (o .:? "news")

-- | ToJSON TopNews200ResponseTopNewsInner
instance A.ToJSON TopNews200ResponseTopNewsInner where
  toJSON TopNews200ResponseTopNewsInner {..} =
   _omitNulls
      [ "news" .= topNews200ResponseTopNewsInnerNews
      ]


-- | Construct a value of type 'TopNews200ResponseTopNewsInner' (by applying it's required fields, if any)
mkTopNews200ResponseTopNewsInner
  :: TopNews200ResponseTopNewsInner
mkTopNews200ResponseTopNewsInner =
  TopNews200ResponseTopNewsInner
  { topNews200ResponseTopNewsInnerNews = Nothing
  }

-- ** TopNews200ResponseTopNewsInnerNewsInner
-- | TopNews200ResponseTopNewsInnerNewsInner
data TopNews200ResponseTopNewsInnerNewsInner = TopNews200ResponseTopNewsInnerNewsInner
  { topNews200ResponseTopNewsInnerNewsInnerSummary :: !(Maybe Text) -- ^ "summary"
  , topNews200ResponseTopNewsInnerNewsInnerImage :: !(Maybe Text) -- ^ "image"
  , topNews200ResponseTopNewsInnerNewsInnerId :: !(Maybe Int) -- ^ "id"
  , topNews200ResponseTopNewsInnerNewsInnerText :: !(Maybe Text) -- ^ "text"
  , topNews200ResponseTopNewsInnerNewsInnerTitle :: !(Maybe Text) -- ^ "title"
  , topNews200ResponseTopNewsInnerNewsInnerPublishDate :: !(Maybe Text) -- ^ "publish_date"
  , topNews200ResponseTopNewsInnerNewsInnerUrl :: !(Maybe Text) -- ^ "url"
  , topNews200ResponseTopNewsInnerNewsInnerAuthors :: !(Maybe [Text]) -- ^ "authors"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TopNews200ResponseTopNewsInnerNewsInner
instance A.FromJSON TopNews200ResponseTopNewsInnerNewsInner where
  parseJSON = A.withObject "TopNews200ResponseTopNewsInnerNewsInner" $ \o ->
    TopNews200ResponseTopNewsInnerNewsInner
      <$> (o .:? "summary")
      <*> (o .:? "image")
      <*> (o .:? "id")
      <*> (o .:? "text")
      <*> (o .:? "title")
      <*> (o .:? "publish_date")
      <*> (o .:? "url")
      <*> (o .:? "authors")

-- | ToJSON TopNews200ResponseTopNewsInnerNewsInner
instance A.ToJSON TopNews200ResponseTopNewsInnerNewsInner where
  toJSON TopNews200ResponseTopNewsInnerNewsInner {..} =
   _omitNulls
      [ "summary" .= topNews200ResponseTopNewsInnerNewsInnerSummary
      , "image" .= topNews200ResponseTopNewsInnerNewsInnerImage
      , "id" .= topNews200ResponseTopNewsInnerNewsInnerId
      , "text" .= topNews200ResponseTopNewsInnerNewsInnerText
      , "title" .= topNews200ResponseTopNewsInnerNewsInnerTitle
      , "publish_date" .= topNews200ResponseTopNewsInnerNewsInnerPublishDate
      , "url" .= topNews200ResponseTopNewsInnerNewsInnerUrl
      , "authors" .= topNews200ResponseTopNewsInnerNewsInnerAuthors
      ]


-- | Construct a value of type 'TopNews200ResponseTopNewsInnerNewsInner' (by applying it's required fields, if any)
mkTopNews200ResponseTopNewsInnerNewsInner
  :: TopNews200ResponseTopNewsInnerNewsInner
mkTopNews200ResponseTopNewsInnerNewsInner =
  TopNews200ResponseTopNewsInnerNewsInner
  { topNews200ResponseTopNewsInnerNewsInnerSummary = Nothing
  , topNews200ResponseTopNewsInnerNewsInnerImage = Nothing
  , topNews200ResponseTopNewsInnerNewsInnerId = Nothing
  , topNews200ResponseTopNewsInnerNewsInnerText = Nothing
  , topNews200ResponseTopNewsInnerNewsInnerTitle = Nothing
  , topNews200ResponseTopNewsInnerNewsInnerPublishDate = Nothing
  , topNews200ResponseTopNewsInnerNewsInnerUrl = Nothing
  , topNews200ResponseTopNewsInnerNewsInnerAuthors = Nothing
  }




-- * Auth Methods

-- ** AuthApiKeyApiKey
data AuthApiKeyApiKey =
  AuthApiKeyApiKey Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeyApiKey where
  applyAuthMethod _ a@(AuthApiKeyApiKey secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setQuery` toQuery ("api-key", Just secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req

-- ** AuthApiKeyHeaderApiKey
data AuthApiKeyHeaderApiKey =
  AuthApiKeyHeaderApiKey Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeyHeaderApiKey where
  applyAuthMethod _ a@(AuthApiKeyHeaderApiKey secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("x-api-key", secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req


