{-
   World News API

   The world's news wrapped into a single API.

   OpenAPI Version: 3.0.0
   World News API API version: 1.0
   Contact: mail@worldnewsapi.com
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : WorldNews.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module WorldNews.Model where

import WorldNews.Core
import WorldNews.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** Analyze
newtype Analyze = Analyze { unAnalyze :: Bool } deriving (P.Eq, P.Show)

-- ** ApiKey
newtype ApiKey = ApiKey { unApiKey :: Text } deriving (P.Eq, P.Show)

-- ** Authors
newtype Authors = Authors { unAuthors :: Text } deriving (P.Eq, P.Show)

-- ** EarliestPublishDate
newtype EarliestPublishDate = EarliestPublishDate { unEarliestPublishDate :: Text } deriving (P.Eq, P.Show)

-- ** Entities
newtype Entities = Entities { unEntities :: Text } deriving (P.Eq, P.Show)

-- ** ExtractNews2
newtype ExtractNews2 = ExtractNews2 { unExtractNews2 :: Bool } deriving (P.Eq, P.Show)

-- ** Language
newtype Language = Language { unLanguage :: Text } deriving (P.Eq, P.Show)

-- ** LatestPublishDate
newtype LatestPublishDate = LatestPublishDate { unLatestPublishDate :: Text } deriving (P.Eq, P.Show)

-- ** Location
newtype Location = Location { unLocation :: Text } deriving (P.Eq, P.Show)

-- ** LocationFilter
newtype LocationFilter = LocationFilter { unLocationFilter :: Text } deriving (P.Eq, P.Show)

-- ** MaxSentiment
newtype MaxSentiment = MaxSentiment { unMaxSentiment :: Double } deriving (P.Eq, P.Show)

-- ** MinSentiment
newtype MinSentiment = MinSentiment { unMinSentiment :: Double } deriving (P.Eq, P.Show)

-- ** NewsSources
newtype NewsSources = NewsSources { unNewsSources :: Text } deriving (P.Eq, P.Show)

-- ** Number
newtype Number = Number { unNumber :: Int } deriving (P.Eq, P.Show)

-- ** Offset
newtype Offset = Offset { unOffset :: Int } deriving (P.Eq, P.Show)

-- ** ParamText
newtype ParamText = ParamText { unParamText :: Text } deriving (P.Eq, P.Show)

-- ** Prefix
newtype Prefix = Prefix { unPrefix :: Text } deriving (P.Eq, P.Show)

-- ** Sort
newtype Sort = Sort { unSort :: E'Sort } deriving (P.Eq, P.Show)

-- ** SortDirection
newtype SortDirection = SortDirection { unSortDirection :: E'SortDirection } deriving (P.Eq, P.Show)

-- ** SourceCountries
newtype SourceCountries = SourceCountries { unSourceCountries :: Text } deriving (P.Eq, P.Show)

-- ** SubDomain
newtype SubDomain = SubDomain { unSubDomain :: Bool } deriving (P.Eq, P.Show)

-- ** Url
newtype Url = Url { unUrl :: Text } deriving (P.Eq, P.Show)

-- * Models


-- ** InlineResponse200
-- | InlineResponse200
data InlineResponse200 = InlineResponse200
  { inlineResponse200Offset :: !(Int) -- ^ /Required/ "offset"
  , inlineResponse200Number :: !(Int) -- ^ /Required/ "number"
  , inlineResponse200Available :: !(Int) -- ^ /Required/ "available"
  , inlineResponse200News :: !([InlineResponse200News]) -- ^ /Required/ "news"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse200
instance A.FromJSON InlineResponse200 where
  parseJSON = A.withObject "InlineResponse200" $ \o ->
    InlineResponse200
      <$> (o .:  "offset")
      <*> (o .:  "number")
      <*> (o .:  "available")
      <*> (o .:  "news")

-- | ToJSON InlineResponse200
instance A.ToJSON InlineResponse200 where
  toJSON InlineResponse200 {..} =
   _omitNulls
      [ "offset" .= inlineResponse200Offset
      , "number" .= inlineResponse200Number
      , "available" .= inlineResponse200Available
      , "news" .= inlineResponse200News
      ]


-- | Construct a value of type 'InlineResponse200' (by applying it's required fields, if any)
mkInlineResponse200
  :: Int -- ^ 'inlineResponse200Offset' 
  -> Int -- ^ 'inlineResponse200Number' 
  -> Int -- ^ 'inlineResponse200Available' 
  -> [InlineResponse200News] -- ^ 'inlineResponse200News' 
  -> InlineResponse200
mkInlineResponse200 inlineResponse200Offset inlineResponse200Number inlineResponse200Available inlineResponse200News =
  InlineResponse200
  { inlineResponse200Offset
  , inlineResponse200Number
  , inlineResponse200Available
  , inlineResponse200News
  }

-- ** InlineResponse2001
-- | InlineResponse2001
data InlineResponse2001 = InlineResponse2001
  { inlineResponse2001Title :: !(Maybe Text) -- ^ "title"
  , inlineResponse2001Text :: !(Maybe Text) -- ^ "text"
  , inlineResponse2001Url :: !(Maybe Text) -- ^ "url"
  , inlineResponse2001Image :: !(Maybe Text) -- ^ "image"
  , inlineResponse2001Author :: !(Maybe Text) -- ^ "author"
  , inlineResponse2001Language :: !(Maybe Text) -- ^ "language"
  , inlineResponse2001SourceCountry :: !(Maybe Text) -- ^ "source_country"
  , inlineResponse2001Sentiment :: !(Maybe Double) -- ^ "sentiment"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2001
instance A.FromJSON InlineResponse2001 where
  parseJSON = A.withObject "InlineResponse2001" $ \o ->
    InlineResponse2001
      <$> (o .:? "title")
      <*> (o .:? "text")
      <*> (o .:? "url")
      <*> (o .:? "image")
      <*> (o .:? "author")
      <*> (o .:? "language")
      <*> (o .:? "source_country")
      <*> (o .:? "sentiment")

-- | ToJSON InlineResponse2001
instance A.ToJSON InlineResponse2001 where
  toJSON InlineResponse2001 {..} =
   _omitNulls
      [ "title" .= inlineResponse2001Title
      , "text" .= inlineResponse2001Text
      , "url" .= inlineResponse2001Url
      , "image" .= inlineResponse2001Image
      , "author" .= inlineResponse2001Author
      , "language" .= inlineResponse2001Language
      , "source_country" .= inlineResponse2001SourceCountry
      , "sentiment" .= inlineResponse2001Sentiment
      ]


-- | Construct a value of type 'InlineResponse2001' (by applying it's required fields, if any)
mkInlineResponse2001
  :: InlineResponse2001
mkInlineResponse2001 =
  InlineResponse2001
  { inlineResponse2001Title = Nothing
  , inlineResponse2001Text = Nothing
  , inlineResponse2001Url = Nothing
  , inlineResponse2001Image = Nothing
  , inlineResponse2001Author = Nothing
  , inlineResponse2001Language = Nothing
  , inlineResponse2001SourceCountry = Nothing
  , inlineResponse2001Sentiment = Nothing
  }

-- ** InlineResponse2002
-- | InlineResponse2002
data InlineResponse2002 = InlineResponse2002
  { inlineResponse2002NewsLinks :: !(Maybe [Text]) -- ^ "news_links"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2002
instance A.FromJSON InlineResponse2002 where
  parseJSON = A.withObject "InlineResponse2002" $ \o ->
    InlineResponse2002
      <$> (o .:? "news_links")

-- | ToJSON InlineResponse2002
instance A.ToJSON InlineResponse2002 where
  toJSON InlineResponse2002 {..} =
   _omitNulls
      [ "news_links" .= inlineResponse2002NewsLinks
      ]


-- | Construct a value of type 'InlineResponse2002' (by applying it's required fields, if any)
mkInlineResponse2002
  :: InlineResponse2002
mkInlineResponse2002 =
  InlineResponse2002
  { inlineResponse2002NewsLinks = Nothing
  }

-- ** InlineResponse2003
-- | InlineResponse2003
data InlineResponse2003 = InlineResponse2003
  { inlineResponse2003Latitude :: !(Double) -- ^ /Required/ "latitude"
  , inlineResponse2003Longitude :: !(Double) -- ^ /Required/ "longitude"
  , inlineResponse2003City :: !(Maybe Text) -- ^ "city"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse2003
instance A.FromJSON InlineResponse2003 where
  parseJSON = A.withObject "InlineResponse2003" $ \o ->
    InlineResponse2003
      <$> (o .:  "latitude")
      <*> (o .:  "longitude")
      <*> (o .:? "city")

-- | ToJSON InlineResponse2003
instance A.ToJSON InlineResponse2003 where
  toJSON InlineResponse2003 {..} =
   _omitNulls
      [ "latitude" .= inlineResponse2003Latitude
      , "longitude" .= inlineResponse2003Longitude
      , "city" .= inlineResponse2003City
      ]


-- | Construct a value of type 'InlineResponse2003' (by applying it's required fields, if any)
mkInlineResponse2003
  :: Double -- ^ 'inlineResponse2003Latitude' 
  -> Double -- ^ 'inlineResponse2003Longitude' 
  -> InlineResponse2003
mkInlineResponse2003 inlineResponse2003Latitude inlineResponse2003Longitude =
  InlineResponse2003
  { inlineResponse2003Latitude
  , inlineResponse2003Longitude
  , inlineResponse2003City = Nothing
  }

-- ** InlineResponse200News
-- | InlineResponse200News
data InlineResponse200News = InlineResponse200News
  { inlineResponse200NewsId :: !(Maybe Int) -- ^ "id"
  , inlineResponse200NewsTitle :: !(Maybe Text) -- ^ "title"
  , inlineResponse200NewsText :: !(Maybe Text) -- ^ "text"
  , inlineResponse200NewsSummary :: !(Maybe Text) -- ^ "summary"
  , inlineResponse200NewsUrl :: !(Maybe Text) -- ^ "url"
  , inlineResponse200NewsImage :: !(Maybe Text) -- ^ "image"
  , inlineResponse200NewsAuthor :: !(Maybe Text) -- ^ "author"
  , inlineResponse200NewsLanguage :: !(Maybe Text) -- ^ "language"
  , inlineResponse200NewsSourceCountry :: !(Maybe Text) -- ^ "source_country"
  , inlineResponse200NewsSentiment :: !(Maybe Double) -- ^ "sentiment"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse200News
instance A.FromJSON InlineResponse200News where
  parseJSON = A.withObject "InlineResponse200News" $ \o ->
    InlineResponse200News
      <$> (o .:? "id")
      <*> (o .:? "title")
      <*> (o .:? "text")
      <*> (o .:? "summary")
      <*> (o .:? "url")
      <*> (o .:? "image")
      <*> (o .:? "author")
      <*> (o .:? "language")
      <*> (o .:? "source_country")
      <*> (o .:? "sentiment")

-- | ToJSON InlineResponse200News
instance A.ToJSON InlineResponse200News where
  toJSON InlineResponse200News {..} =
   _omitNulls
      [ "id" .= inlineResponse200NewsId
      , "title" .= inlineResponse200NewsTitle
      , "text" .= inlineResponse200NewsText
      , "summary" .= inlineResponse200NewsSummary
      , "url" .= inlineResponse200NewsUrl
      , "image" .= inlineResponse200NewsImage
      , "author" .= inlineResponse200NewsAuthor
      , "language" .= inlineResponse200NewsLanguage
      , "source_country" .= inlineResponse200NewsSourceCountry
      , "sentiment" .= inlineResponse200NewsSentiment
      ]


-- | Construct a value of type 'InlineResponse200News' (by applying it's required fields, if any)
mkInlineResponse200News
  :: InlineResponse200News
mkInlineResponse200News =
  InlineResponse200News
  { inlineResponse200NewsId = Nothing
  , inlineResponse200NewsTitle = Nothing
  , inlineResponse200NewsText = Nothing
  , inlineResponse200NewsSummary = Nothing
  , inlineResponse200NewsUrl = Nothing
  , inlineResponse200NewsImage = Nothing
  , inlineResponse200NewsAuthor = Nothing
  , inlineResponse200NewsLanguage = Nothing
  , inlineResponse200NewsSourceCountry = Nothing
  , inlineResponse200NewsSentiment = Nothing
  }

-- ** News
-- | News
-- News
-- 
-- A news entry.
data News = News
  { newsId :: !(Maybe Int) -- ^ "id"
  , newsTitle :: !(Maybe Text) -- ^ "title"
  , newsText :: !(Maybe Text) -- ^ "text"
  , newsSummary :: !(Maybe Text) -- ^ "summary"
  , newsUrl :: !(Maybe Text) -- ^ "url"
  , newsImage :: !(Maybe Text) -- ^ "image"
  , newsPublishDate :: !(Maybe Text) -- ^ "publish_date"
  , newsAuthor :: !(Maybe Text) -- ^ "author"
  , newsLanguage :: !(Maybe Text) -- ^ "language"
  , newsSourceCountry :: !(Maybe Text) -- ^ "source_country"
  , newsSentiment :: !(Maybe Double) -- ^ "sentiment"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON News
instance A.FromJSON News where
  parseJSON = A.withObject "News" $ \o ->
    News
      <$> (o .:? "id")
      <*> (o .:? "title")
      <*> (o .:? "text")
      <*> (o .:? "summary")
      <*> (o .:? "url")
      <*> (o .:? "image")
      <*> (o .:? "publish_date")
      <*> (o .:? "author")
      <*> (o .:? "language")
      <*> (o .:? "source_country")
      <*> (o .:? "sentiment")

-- | ToJSON News
instance A.ToJSON News where
  toJSON News {..} =
   _omitNulls
      [ "id" .= newsId
      , "title" .= newsTitle
      , "text" .= newsText
      , "summary" .= newsSummary
      , "url" .= newsUrl
      , "image" .= newsImage
      , "publish_date" .= newsPublishDate
      , "author" .= newsAuthor
      , "language" .= newsLanguage
      , "source_country" .= newsSourceCountry
      , "sentiment" .= newsSentiment
      ]


-- | Construct a value of type 'News' (by applying it's required fields, if any)
mkNews
  :: News
mkNews =
  News
  { newsId = Nothing
  , newsTitle = Nothing
  , newsText = Nothing
  , newsSummary = Nothing
  , newsUrl = Nothing
  , newsImage = Nothing
  , newsPublishDate = Nothing
  , newsAuthor = Nothing
  , newsLanguage = Nothing
  , newsSourceCountry = Nothing
  , newsSentiment = Nothing
  }


-- * Enums


-- ** E'Sort

-- | Enum of 'Text'
data E'Sort
  = E'Sort'Relevance -- ^ @"relevance"@
  | E'Sort'Publish_time -- ^ @"publish-time"@
  | E'Sort'Sentiment -- ^ @"sentiment"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Sort where toJSON = A.toJSON . fromE'Sort
instance A.FromJSON E'Sort where parseJSON o = P.either P.fail (pure . P.id) . toE'Sort =<< A.parseJSON o
instance WH.ToHttpApiData E'Sort where toQueryParam = WH.toQueryParam . fromE'Sort
instance WH.FromHttpApiData E'Sort where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Sort
instance MimeRender MimeMultipartFormData E'Sort where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Sort' enum
fromE'Sort :: E'Sort -> Text
fromE'Sort = \case
  E'Sort'Relevance -> "relevance"
  E'Sort'Publish_time -> "publish-time"
  E'Sort'Sentiment -> "sentiment"

-- | parse 'E'Sort' enum
toE'Sort :: Text -> P.Either String E'Sort
toE'Sort = \case
  "relevance" -> P.Right E'Sort'Relevance
  "publish-time" -> P.Right E'Sort'Publish_time
  "sentiment" -> P.Right E'Sort'Sentiment
  s -> P.Left $ "toE'Sort: enum parse failure: " P.++ P.show s


-- ** E'SortDirection

-- | Enum of 'Text'
data E'SortDirection
  = E'SortDirection'Asc -- ^ @"asc"@
  | E'SortDirection'Desc -- ^ @"desc"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'SortDirection where toJSON = A.toJSON . fromE'SortDirection
instance A.FromJSON E'SortDirection where parseJSON o = P.either P.fail (pure . P.id) . toE'SortDirection =<< A.parseJSON o
instance WH.ToHttpApiData E'SortDirection where toQueryParam = WH.toQueryParam . fromE'SortDirection
instance WH.FromHttpApiData E'SortDirection where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'SortDirection
instance MimeRender MimeMultipartFormData E'SortDirection where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'SortDirection' enum
fromE'SortDirection :: E'SortDirection -> Text
fromE'SortDirection = \case
  E'SortDirection'Asc -> "asc"
  E'SortDirection'Desc -> "desc"

-- | parse 'E'SortDirection' enum
toE'SortDirection :: Text -> P.Either String E'SortDirection
toE'SortDirection = \case
  "asc" -> P.Right E'SortDirection'Asc
  "desc" -> P.Right E'SortDirection'Desc
  s -> P.Left $ "toE'SortDirection: enum parse failure: " P.++ P.show s


-- * Auth Methods

-- ** AuthApiKeyApiKey
data AuthApiKeyApiKey =
  AuthApiKeyApiKey Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeyApiKey where
  applyAuthMethod _ a@(AuthApiKeyApiKey secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setQuery` toQuery ("api-key", Just secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req

-- ** AuthApiKeyHeaderApiKey
data AuthApiKeyHeaderApiKey =
  AuthApiKeyHeaderApiKey Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeyHeaderApiKey where
  applyAuthMethod _ a@(AuthApiKeyHeaderApiKey secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("x-api-key", secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req


